import xarray as xr
import pandas as pd
import numpy as np
import geopandas as gpd
from scipy.ndimage import gaussian_filter
import tempfile
import datetime as dt

def generate_weather_nc(lidar_file, seed):
    np.random.seed(seed)

    # Load DEM data
    dem = gpd.read_file(lidar_file)
    lat = np.array([p.y for p in dem.geometry])
    lon = np.array([p.x for p in dem.geometry])
    elevation = dem['elevation'].values
    slope = dem['slope'].values

    # Reshape into grid
    n_points = int(np.sqrt(len(lat)))
    lat_grid = lat.reshape((n_points, n_points))
    lon_grid = lon.reshape((n_points, n_points))
    elevation_grid = elevation.reshape((n_points, n_points))
    slope_grid = slope.reshape((n_points, n_points))

    # Time dimension
    times = pd.date_range("2023-01-01", "2023-12-31 23:00:00", freq="h")

    # Base weather signals
    base_wind_speed = (
        5 + 5 * np.sin(2 * np.pi * np.arange(len(times)) / 24)
        + np.random.normal(0, 2, len(times))
    )
    wind_factor = 0.01 * elevation_grid + 0.005 * slope_grid
    wind_factor = gaussian_filter(wind_factor, sigma=2)

    # Weather arrays
    wind_speed = np.zeros((len(times), n_points, n_points))
    pressure = np.zeros((len(times), n_points, n_points))

    for t in range(len(times)):
        wind_speed[t] = (
            base_wind_speed[t]
            + wind_factor
            + np.random.normal(0, 1, (n_points, n_points))
        )
        pressure[t] = (
            1013 - 0.1 * elevation_grid
            + np.random.normal(0, 5, (n_points, n_points))
        )

    thermal = wind_speed * 1000 / pressure
    turbine_active = wind_speed > 3

    # Create dataset
    ds = xr.Dataset(
        {
            "wind_speed": (["time", "lat", "lon"], wind_speed, {
                "units": "m s-1",
                "standard_name": "wind_speed",
                "long_name": "Wind speed at hub height"
            }),
            "pressure": (["time", "lat", "lon"], pressure, {
                "units": "hPa",
                "standard_name": "air_pressure",
                "long_name": "Air pressure at surface"
            }),
            "thermal": (["time", "lat", "lon"], thermal, {
                "units": "m2 s-2 hPa-1",
                "long_name": "Thermal uplift potential"
            }),
            "turbine_active": (["time", "lat", "lon"], turbine_active, {
                "units": "1",
                "long_name": "Turbine active flag (1=active)"
            }),
            "elevation": (["lat", "lon"], elevation_grid, {
                "units": "m",
                "standard_name": "surface_altitude"
            }),
            "slope": (["lat", "lon"], slope_grid, {
                "units": "degrees",
                "long_name": "Surface slope"
            })
        },
        coords={
            "time": times,
            "lat": (["lat"], np.linspace(-34.2, -33.6, n_points), {
                "units": "degrees_north",
                "standard_name": "latitude"
            }),
            "lon": (["lon"], np.linspace(25.3, 25.9, n_points), {
                "units": "degrees_east",
                "standard_name": "longitude"
            })
        },
        attrs={
            "title": "Synthetic Weather Dataset",
            "institution": "Generated by black_harrier_abm",
            "source": "Simulated from DEM and random weather model",
            "history": f"Created {dt.datetime.utcnow().isoformat()} UTC",
            "references": "None"
        }
    )

    # Save to NetCDF with CF-compliant encoding for time
    with tempfile.NamedTemporaryFile(suffix='.nc', delete=False) as f:
        ds.to_netcdf(
            f.name,
            encoding={
                "time": {
                    "dtype": "int32",
                    "units": "hours since 2023-01-01 00:00:00",
                    "calendar": "gregorian"
                }
            }
        )
        return f.name
